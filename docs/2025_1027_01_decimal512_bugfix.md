# Decimal512 Bug 修复：buffer too small 错误

## 问题描述
在使用 Decimal512 时，当数值经过 scale 调整后超过 512 位时，`bigIntToRaw` 调用 `big.Int.FillBytes` 会 panic：
```
panic: math/big: buffer too small to fit value
```

## 根本原因
1. **精度理解错误**：`Decimal(P, S)` 中 P 是总位数（整数+小数），S 是小数位数
   - 例如 `Decimal(153, 50)` 表示：总共 153 位十进制数字，其中 50 位小数
   - 所以整数部分最多只能有 **103 位**（153 - 50）

2. **测试数据错误**：示例中的 `amount_large` 定义为 `Decimal(153, 50)`，但测试数据整数部分有 112 位：
   ```go
   amountLarge: "1234567890...（112位）...12345678901234567890...（50位）..."
   ```

3. **编码溢出**：当乘以 10^50 进行 scale 调整时，153 位十进制 ≈ 508 位二进制，接近 512 位边界，加上可能的符号位处理，容易超出 64 字节缓冲区。

## 修复方案
1. **增加边界检查**：在 `append` 方法中检查 `BigInt` 的位长度，超过 512 位时返回清晰错误
2. **改进错误处理**：将 `append` 方法改为返回 `error`，并在调用处处理错误

## 修改文件
- `lib/column/decimal.go`
  - 将 `func (col *Decimal) append(v *decimal.Decimal)` 改为返回 `error`
  - 在 Decimal512 分支增加 `bi.BitLen() > 512` 检查
  - 更新所有调用 `append` 的地方处理返回的 error

## 测试数据修正建议
对于 `Decimal(153, 50)`：
- 整数部分最多 103 位：`10^103 - 1` 约为 `9999...9999`（103个9）
- 小数部分 50 位
- 建议测试数据示例：
  ```go
  // 正确：整数部分 50 位 + 小数部分 50 位 = 总共 100 位 < 153
  "12345678901234567890123456789012345678901234567890.12345678901234567890123456789012345678901234567890"
  
  // 边界：整数部分 103 位 + 小数部分 50 位 = 总共 153 位
  "1234567890...（重复至103位）.12345678...（重复至50位）"
  ```

## 后续优化
- 考虑在 `parse` 阶段就验证 precision 与 scale 的合理性
- 提供更友好的错误提示，说明数值范围限制
- 在文档中明确 Decimal512 的精度限制（154 位十进制 ≈ 512 位二进制）

